import pika
from pika import spec
from pika.adapters.blocking_connection import BlockingChannel

connection = pika.BlockingConnection(
    pika.ConnectionParameters(host="localhost")
)

channel = connection.channel()

channel.exchange_declare( 
    exchange="logs",
    exchange_type="fanout",
)

result: spec.Queue.DeclareOk = channel.queue_declare(
    queue="", # This creates a new queue with a random name, generated by RMQ. 
    exclusive=True, # This queue will be deleted once the consumer connection is closed.
                    # Thus turning it into a private and temporary queue.
)

queue_name = result.method.queue # This is how we get the name of the queue that RMQ generated for us on this channel.

channel.queue_bind(
    exchange="logs",
    queue=queue_name,
) # Binds the queue to the exchange
# This means that the queue is interested in messages from this exchange. 
# And as the exchange type is fanout, it will receive all messages.
# Is this the 'subscribe' part?


print(' [*] Waiting for logs. To exit press CTRL+C')

def callback(
    ch: BlockingChannel, 
    method: spec.Basic.Deliver,
    properties: spec.BasicProperties,
    body: bytes
) -> None:
    print(f" [x] {body}")

channel.basic_consume( 
    queue=queue_name,
    on_message_callback=callback,
    auto_ack=True, # This tells RMQ to automatically acknowledge the message once it has been received.
                    # Note: This is potentially dangerous, as it can lead to message loss if the consumer dies before processing the message,
                    # as it sends the ack right after receiving the message, before processing it.
)

channel.start_consuming()
